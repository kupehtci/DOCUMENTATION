#VAULT 

# Vault - Authentication and Authorization

# Authentication

Authentication in Vault is how an user, app or service proves their identity to the secret storage service. 

It supports many authentication methods depending on the use case: 

| Category                       | Auth Method           | Description / Use Case                                                                      |
| ------------------------------ | --------------------- | ------------------------------------------------------------------------------------------- |
| **Static / Built-in**          | **Token**             | Basic and default method. Tokens can be manually created or generated by other logins.      |
| **Human Users**                | **Userpass**          | Simple username/password login, often used in dev or demos.                                 |
|                                | **LDAP**              | Integrate with corporate LDAP or Active Directory.                                          |
|                                | **Okta / OIDC / JWT** | Login with SSO providers (e.g., Azure AD, Google, GitHub, Okta).                            |
| **Machines / Applications**    | **AppRole**           | Auth designed for applications or automation â€” provides role-id and secret-id credentials.  |
|                                | **Kubernetes**        | Pods authenticate to Vault using Kubernetes service account JWTs.                           |
|                                | **AWS / Azure / GCP** | Authenticate instances or workloads running in those clouds using their cloud IAM identity. |
|                                | **TLS Certificates**  | Authenticate via mutual TLS client certificates.                                            |
| **Others / Special Use Cases** | **GitHub**            | Developers authenticate using GitHub personal access tokens (useful for small teams).       |
|                                | **RADIUS**            | Legacy enterprise system integration.                                                       |

The authentication flow that an application or service must follow to authenticate in Vault is the following: 

1. The app authenticated to the `login` api endpoint using one of the Auth methods stablished (`userpass`, `approle` or `kubernetes`).
2. The vault verifies the credentials and issues a token. 
	* The token carries one or more policies that define the permissions of that identity to work with Vault. 
3. The client can use the token in `X-Vault-Token` HTTP header to do API calls to the Vault. 

You can also login using the Vault CLI: 

```bash
vault login -method=userpass username=alex password=mypassword123
```

Each authentication method is mounted under a path, normally `v1/auth/<method>/login`, example for user `v1/auth/userpass/login/<username>`: 

```bash
curl --request POST \
     --data '{"password": "mypassword123"}' \
     http://localhost:8200/v1/auth/userpass/login/daniel
```

And it will return a json containing `.auth.client_token` that need to be inserted in `X-Vault-Token` http header: 

```bash
curl --header "X-Vault-Token: <token>" \
     http://localhost:8200/v1/secret/example
```

# Authorization

Vault uses HCL-based policies for defining the permission boundaries of what the different identities can do. 

An example of an HCL is: 
```hcl
path "secret/data/dev/*" {
	capabilities = ["read", "write"]
}
```

Then loaded into Vault using `vault policy write` command: 

``` bash
vault policy write dev-read dev-read.hcl
```

So then this policy can be attached to an identity to give permissions. 

The policy is path-based, so you define for a certain path that stores secrets, the capabilities or permissions that are granted over it. 

You can define the following capabilities: 
* `create`
* `read`
* `update`
* `delete`
* `list`
* `sudo`
* `deny`: deny the access to that path. 

## Create policies

You can create custom policies in the `Policies` sidebar tab: 

![[vault-policies.png]]

